/*
 * Powered by the awesome project `wait.for`
 * Go check it out on http://npmjs.com/package/wait.for :)
 */
"use strict";
const Fiber = require('fibers');

/*
 * --------------------------------------------------------------------------------------------------------------------
 * The main class
 * --------------------------------------------------------------------------------------------------------------------
 */
class WaitForIt {
    //noinspection JSUnusedGlobalSymbols,ReservedWordAsName
    static new() {
        return new WaitForIt();
    }

    /**
     * Set some ivars
     */
    constructor() {
        this.Errors = {
            ERR_NO_FIBER: 'wait.for can only be called inside a fiber!',
            ERR_NO_FUNCTION: 'wait.for: {num} argument must be an async function!',
            ERR_NO_CONTEXT: 'wait.for: You have to pass "this" as {num} argument. \n If you want to use strict-mode use wait.launchFiber(...) instead of wait.launchLaxFiber(...)'
        };

        this.LAX_EMPTY_CONTEXT = "LAX_EMPTY_CONTEXT";
    }

    //noinspection JSUnusedGlobalSymbols
    /**
     * Create a new Fiber without context
     */
    createFiber(func) {
        return this.createLaxFiber.apply(this, __arguments.withContext(this.LAX_EMPTY_CONTEXT, arguments));
    }

    /**
     * Create a new Fiber with context
     */
    createLaxFiber(context, func) {
        if (typeof context !== 'object' && context !== this.LAX_EMPTY_CONTEXT) {
            throw new Error(this.Errors.ERR_NO_CONTEXT.replace('{num}', 'first'));
        }

        if (typeof func !== 'function') {
            throw new Error(this.Errors.ERR_NO_FUNCTION.replace('{num}', 'second'));
        }

        // Get the matching context
        let ctext = context === this.LAX_EMPTY_CONTEXT ? null : context;

        // Drop context and func from arguments
        let args = __arguments.drop(arguments, 2);

        // Run
        //noinspection JSUnresolvedFunction
        Fiber(function () {
            func.apply(ctext, args);
        }).run();
    }

    /**
     * Works like Function.__proto__.apply(...) but waits for results
     */
    syncApply(context, func, args) {
        //noinspection JSUnresolvedVariable
        let fiber = Fiber.current;
        if (!fiber) {
            throw new Error(this.Errors.ERR_NO_FIBER);
        }

        // Create a closure to resume on callback
        let resumeCallback = function (err, data) {
            if (fiber.callbackAlreadyCalled) {
                throw new Error("Callback for function " + func.name + " called twice. Wait.for already resumed the execution.");
            }

            fiber.callbackAlreadyCalled = true;
            fiber.err = err;
            fiber.data = data;

            if (fiber.yielded) {
                fiber.run();
            }
        };

        // Add resumeCallback to arguments
        args.push(resumeCallback);

        fiber.callbackAlreadyCalled = false;
        fiber.yielded = false;

        // Call async function/method...
        func.apply(context, args);

        // ...except callback was called before async fn return
        if (!fiber.callbackAlreadyCalled) {
            fiber.yielded = true;

            // Pause fiber, until callback => wait for results
            //noinspection JSUnresolvedFunction
            Fiber.yield();
        }

        if (fiber.err) {
            // Re-throw fiber errors
            throw fiber.err;
        }

        // Return data on success
        return fiber.data;
    }

    //noinspection JSUnusedGlobalSymbols,ReservedWordAsName
    for(func) {
        try {
            return this.laxFor.apply(this, __arguments.withContext(this.LAX_EMPTY_CONTEXT, arguments));
        } catch (e) {
            // Re-throw with other {num}
            if (e.message.indexOf(this.Errors.ERR_NO_FUNCTION) !== -1) {
                throw new Error(this.Errors.ERR_NO_FUNCTION.replace('{num}', 'first'));
            } else {
                throw e;
            }
        }
    }

    laxFor(context, func) {
        if (typeof func !== 'function') {
            throw new Error(this.Errors.ERR_NO_FUNCTION.replace('{num}', 'second'));
        }

        // Drop context and func from arguments
        let args = __arguments.drop(arguments, 2);

        return this.syncApply(context, func, args);
    }

    //noinspection JSUnusedGlobalSymbols
    forMethod(object, method) {
        return this.laxForMethod.apply(this, __arguments.withContext(this.LAX_EMPTY_CONTEXT, arguments));
    }

    laxForMethod(context, object, method) {
        let m = object[method];
        if (!m) {
            throw new Error('wait.laxForMethod: third argument must be the async method name (string)');
        }

        // Remove context, object and method from args
        let args = __arguments.drop(arguments, 3);

        return this.syncApply(context, m, args);
    }

    //(prefixed) parallel extensions
    /*
     Main Functions:
     wait.parallel.launch = function(functions)
     ----------------------

     Note: must be in a Fiber

     input:
     functions: Array = [func,arg,arg],[func,arg,arg],...

     it launch a fiber for each func
     the fiber do: resultArray[index] = func.apply(undefined,args)

     returns array with a result for each function
     do not "returns" until all fibers complete
     throws if error
     wait.parallel.map = function(arr,mappedFn)
     ----------------------

     Note: must be in a Fiber

     input:
     arr: Array
     mappedFn = function(item,index,arr)

     mappedFn should return converted item. Since we're in a fiber
     mappedFn can use wait.for and also throw/try/catch

     returns array with converted items
     do not "returns" until all fibers complete
     throws if error
     wait.parallel.filter = function(arr, itemTestFn)
     ----------------------
     Note: must be in a Fiber

     input:
     arr: Array
     itemTestFn = function(item,index,arr)

     itemTestFn should return true|false. Since we're in a fiber
     itemTestFn can use wait.for and also throw/try/catch

     returns array with items where itemTestFn() returned true
     do not "returns" until all fibers complete
     throws if error
     */

    parallelTaskJoiner(inx, context, err, data) {

        if (context.finished) return;

        context.count++;
        //console.log('arrived result',inx,err,data,"result.count",context.count,"task",context.taskId);

        if (err) {
            context.finished = true;
            return context.finalCallback(err); //err in one of the fibers
        }
        else
            context.results[inx] = data;

        if (context.count >= context.expected) { // all contexts arrived
            //console.log("finall callback. elements:",context.count);
            context.finished = true;
            return context.finalCallback(null, context.results); // final callback
        }
    }

    parallelFiberForItemBody(inx, context, functionAndArgs) {
        try {
            var data = functionAndArgs[0].apply(undefined, functionAndArgs.slice(1));
            this.parallelTaskJoiner(inx, context, null, data);
        }
        catch (err) {
            this.parallelTaskJoiner(inx, context, err);
        }
    }

    parallelLaunch(functions) {
        //
        // functions = [function,arg,arg],[function,arg,arg],...
        // returns array with results of each func, a fiber is launched for each item
        // wait.parallel.returns when all functions complete
        //
        return this.laxFor(this, this.parallelAsyncLaunch, functions);
    }

    parallelAsyncLaunch(functions, finalCallback) {
        //
        // functions:Array = [function,arg,arg..],[function,arg,arg,...],...
        // call finalCallback array with results of each func, a fiber is launched for each item
        // finalCallback is called when all functions complete
        //
        var context = {
            results: [],
            count: 0,
            expected: functions.length,
            finished: false,
            finalCallback: finalCallback
        };

        if (context.expected === 0) return finalCallback(null, context.results);

        //launch a fiber for each item,
        // each item is an array containing function ptr and arguments
        for (var i = 0; i < functions.length; i++) {
            wait.createLaxFiber(this, this.parallelFiberForItemBody, i, context, functions[i]);
        }
    }

    parallelMap(arr, mappedFn) {
        // must be in a Fiber
        //
        // mappedFn = function(item,index,arr) returns converted item, a fiber is launched for each item
        //
        // convert arr into an array of functions + parameters
        var functions = arr.map(function (item, inx) {
            return [mappedFn, item, inx, arr]
        });
        // launch a fiber for each item. wait until all fibers complete
        return this.parallelLaunch(functions);
    }

    parallelFilter(arr, itemTestFn) {
        // must be in a Fiber
        //
        // mappedFn = function(item,index,arr) returns true/false
        //
        var testResults = this.parallelMap(arr, itemTestFn);

        // create an array for each item where itemTestFn returned true
        var filteredArr = [];
        for (var i = 0; i < arr.length; i++)
            if (testResults[i]) filteredArr.push(arr[i]);

        return filteredArr;
    }
}

/*
 * --------------------------------------------------------------------------------------------------------------------
 * Helper functions (private)
 * --------------------------------------------------------------------------------------------------------------------
 */

/**
 * Convert any object with length property to array
 * @param args
 * @returns {Array.<T>}
 * @private
 */
function __object_to_array(args) {
    if (args !== null && typeof args === 'object') {
        if (args.hasOwnProperty('length')) {
            return Array.prototype.slice.call(args);
        }
    }

    throw new Error('Cannot convert objects without length property to array');
}

/**
 * Drop {count} items from {array}
 * @param array
 * @param count
 * @returns {*}
 * @private
 */
function __array_drop_items(array, count) {
    let tmp = array;
    tmp.splice(0, count);
    return tmp;
}

/**
 * Prepend things to {array}
 * @param array
 * @returns {Array}
 * @private
 */
function __array_prepend(array) {
    let _old = array;
    let args = __array_drop_items(__object_to_array(arguments), 1);

    let _new = [];

    for (let k in args) {
        _new.push(args[k]);
    }

    for (let k in _old) {
        _new.push(_old[k]);
    }

    return _new;
}

/**
 * Argument helper to prevent duplicated code
 * @type {{withContext: __arguments.withContext, drop: __arguments.drop}}
 * @private
 */
const __arguments = {
    withContext: function (context, args) {
        return __array_prepend(__object_to_array(args), context);
    },

    drop: function (args, count) {
        return __array_drop_items(__object_to_array(args), count);
    }
};

module.exports = WaitForIt; //export
